package org.dimensinfin.eveonline.neocom.planetary.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.joda.time.DateTime;

import org.dimensinfin.core.interfaces.ICollaboration;
import org.dimensinfin.eveonline.neocom.domain.NeoComNode;
import org.dimensinfin.eveonline.neocom.domain.NeoItem;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdPlanetsPlanetIdOkContents;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdPlanetsPlanetIdOkPins;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetUniverseTypesTypeIdOkDogmaAttributes;
import org.dimensinfin.eveonline.neocom.planetary.FacilityGeoPosition;
import org.dimensinfin.eveonline.neocom.planetary.IPlanetaryFacility;
import org.dimensinfin.eveonline.neocom.planetary.PlanetType;
import org.dimensinfin.eveonline.neocom.planetary.PlanetaryFacilityType;

/**
 * The class is responsible to keep the data and the logic to be used on the planetary installation programmatic view generation. This
 * activity will not draw standard views but views generated by code to fit the special render requirements.
 */
public class PlanetaryFacility extends NeoComNode implements IPlanetaryFacility, ICollaboration/*, IUniqueModel*/ {
	protected GetCharactersCharacterIdPlanetsPlanetIdOkPins pinDelegate; // The facility esi data.
	private NeoItem planetItemDelegate; // The item data for the installation referenced.
	private FacilityGeoPosition commandCenterPosition;
	private PlanetType planetType = PlanetType.BARREN;

	private int cpuUsage = -1;
	private int powerUsage = -1;

	// - C O N S T R U C T O R S
	private PlanetaryFacility() {}

	// - G E T T E R S   &   S E T T E R S

	/**
	 * The planetaryFacility type can be inferred from the item group type instead than form the long list of unique types that belong to
	 * a planetaryFacility type. With this change the number of check elements is quite short.
	 */
	public PlanetaryFacilityType getFacilityType() {
		return PlanetaryFacilityType.getTypeByStructureGroup( this.planetItemDelegate.getGroupId() );
	}

	public FacilityGeoPosition getCommandCenterPosition() {
		return this.commandCenterPosition;
	}

	public void setCommandCenterPosition( final FacilityGeoPosition commandCenterPosition ) {
		this.commandCenterPosition = commandCenterPosition;
	}

	public FacilityGeoPosition getGeoPosition() {
		return new FacilityGeoPosition()
				.setLongitude( this.getLongitude() )
				.setLatitude( this.getLatitude() );
	}

	public int getCpuUsage() {
		if (this.cpuUsage < 0) {
			final GetUniverseTypesTypeIdOkDogmaAttributes cpu = this.getDogmaAttributeById( 49 );
			if (null == cpu) return 0;
			else this.cpuUsage = Float.valueOf( cpu.getValue() ).intValue();
		}
		return this.cpuUsage;
	}

	public int getPowerUsage() {
		if (this.powerUsage < 0) {
			final GetUniverseTypesTypeIdOkDogmaAttributes power = this.getDogmaAttributeById( 15 );
			if (null == power) return 0;
			else this.powerUsage = Float.valueOf( power.getValue() ).intValue();
		}
		return this.powerUsage;
	}

	public Float getStorageCapacity() {
		final GetUniverseTypesTypeIdOkDogmaAttributes storage = this.getDogmaAttributeById( 38 );
		if (null == storage) return 0.0F;
		else return storage.getValue();
	}

	// - D E L E G A T I O N
	@Override
	public String getTypeIconURL() {
		return this.planetItemDelegate.getTypeIconURL();
	}

	public String getName() {
		return this.planetItemDelegate.getName();
	}

	public List<GetCharactersCharacterIdPlanetsPlanetIdOkContents> getContents() {
		final List<GetCharactersCharacterIdPlanetsPlanetIdOkContents> cont = pinDelegate.getContents();
		if (null == cont) return new ArrayList<>();
		else return cont;
	}

	public PlanetType getPlanetType() {
		return planetType;
	}

	//	public int getBackgroundColor() {
	//		return planetType.getBackgroundColor();
	//	}

	@Override
	public int getIconReferenceId() {
		return 0;
	}

	@Override
	public int getIconColorReference() {
		return 0;
	}

	public DateTime getLastCycleStart() {
		final DateTime start = this.pinDelegate.getLastCycleStart();
		if (null == start) return DateTime.now();
		else return start;
	}

	public IPlanetaryFacility setLastCycleStart( final DateTime lastCycleStart ) {
		this.pinDelegate.setLastCycleStart( lastCycleStart );
		return this;
	}

	public Float getLatitude() {
		return this.pinDelegate.getLatitude();
	}

	public Float getLongitude() {
		return this.pinDelegate.getLongitude();
	}

	public Integer getSchematicId() {
		return this.pinDelegate.getSchematicId();
	}

	public GetUniverseTypesTypeIdOkDogmaAttributes getDogmaAttributeById( final int attributeId ) {
		final List<GetUniverseTypesTypeIdOkDogmaAttributes> attributes = this.planetItemDelegate.getDogmaAttributes();
		for (GetUniverseTypesTypeIdOkDogmaAttributes attribute : attributes) {
			if (attributeId == attribute.getAttributeId()) return attribute;
		}
		return null;
	}

	public int getGroupId() {
		return this.planetItemDelegate.getGroupId();
	}

	// - I U N I Q U E M O D E L
	//	@Override
	public long getUniqueModelIdentifier() {
		return this.pinDelegate.getPinId();
	}

	// - C O R E

	/**
	 * IPlanetaryFacility comparisons for ordering are related to the facility name
	 */
	@Override
	public int compareTo( final Object o ) {
		if (o instanceof IPlanetaryFacility) {
			return this.getFacilityType().getFacilityOrderIndex() - ((IPlanetaryFacility) o).getFacilityType().getFacilityOrderIndex();
		}
		return 0;
	}

	// - B U I L D E R
	public static class Builder {
		private final PlanetaryFacility onConstruction;

		public Builder() {
			this.onConstruction = new PlanetaryFacility();
		}

		public Builder withPin( final GetCharactersCharacterIdPlanetsPlanetIdOkPins pin ) {
			this.onConstruction.pinDelegate = pin;
			return this;
		}

		public Builder withFacilityItem( final NeoItem planetItem ) {
			this.onConstruction.planetItemDelegate = planetItem;
			return this;
		}

		public Builder withPlanetType( final PlanetType planetType ) {
			this.onConstruction.planetType = planetType;
			return this;
		}

		/**
		 * This builder method sets the schematic identifier that is the schematic to be used on the production plan for this facility.
		 * Not all structures have the ability to handle schematics to this is an optional method that should code gracefully with the
		 * case the data origin does not define one schematic.
		 */
		public PlanetaryFacility build() {
			Objects.requireNonNull( this.onConstruction.pinDelegate );
			Objects.requireNonNull( this.onConstruction.planetItemDelegate );
			Objects.requireNonNull( this.onConstruction.planetType );
			return this.onConstruction;
		}
	}
}
