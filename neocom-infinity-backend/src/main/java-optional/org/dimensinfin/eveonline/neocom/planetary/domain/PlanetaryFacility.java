package org.dimensinfin.eveonline.neocom.planetary.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.joda.time.DateTime;

import org.dimensinfin.core.interfaces.ICollaboration;
import org.dimensinfin.eveonline.neocom.domain.EsiType;
import org.dimensinfin.eveonline.neocom.domain.NeoComNode;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdPlanetsPlanetIdOkContents;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetCharactersCharacterIdPlanetsPlanetIdOkPins;
import org.dimensinfin.eveonline.neocom.esiswagger.model.GetUniverseTypesTypeIdOkDogmaAttributes;
import org.dimensinfin.eveonline.neocom.planetary.FacilityGeoPosition;
import org.dimensinfin.eveonline.neocom.planetary.IPlanetaryFacility;
import org.dimensinfin.eveonline.neocom.planetary.PlanetType;
import org.dimensinfin.eveonline.neocom.planetary.PlanetaryFacilityType;

/**
 * The class is responsible to keep the data and the logic to be used on the planetary installation programmatic view generation. This
 * activity will not draw standard views but views generated by code to fit the special render requirements.
 */
public class PlanetaryFacility extends NeoComNode implements IPlanetaryFacility, ICollaboration {
	private static final long serialVersionUID = -1636212521990901770L;
	protected transient GetCharactersCharacterIdPlanetsPlanetIdOkPins pinDelegate; // The facility esi data.
	private EsiType planetItemDelegate; // The item data for the installation referenced.
	private transient FacilityGeoPosition commandCenterPosition;
	private PlanetType planetType = PlanetType.BARREN;

	private int cpuUsage = -1;
	private int powerUsage = -1;

	// - C O N S T R U C T O R S
	private PlanetaryFacility() {}

	// - G E T T E R S   &   S E T T E R S
	public Float getLatitude() {
		return this.pinDelegate.getLatitude();
	}

	public Float getLongitude() {
		return this.pinDelegate.getLongitude();
	}

	@Override
	public String getName() {
		return this.planetItemDelegate.getName();
	}

	@Override
	public PlanetType getPlanetType() {
		return this.planetType;
	}

	@Override
	public int getGroupId() {
		return this.planetItemDelegate.getGroup().getGroupId();
	}

	/**
	 * The planetaryFacility type can be inferred from the item group type instead than form the long list of unique types that belong to
	 * a planetaryFacility type. With this change the number of check elements is quite short.
	 */
	@Override
	public PlanetaryFacilityType getFacilityType() {
		return PlanetaryFacilityType.getTypeByStructureGroup( this.planetItemDelegate.getGroup().getGroupId() );
	}

	@Override
	public int getIconReferenceId() {
		return 0;
	}

	@Override
	public int getIconColorReference() {
		return 0;
	}

	@Override
	public FacilityGeoPosition getGeoPosition() {
		return new FacilityGeoPosition()
				.setLongitude( this.getLongitude() )
				.setLatitude( this.getLatitude() );
	}

	@Override
	public Integer getSchematicId() {
		return this.pinDelegate.getSchematicId();
	}

	@Override
	public DateTime getLastCycleStart() {
		final DateTime start = this.pinDelegate.getLastCycleStart();
		if (null == start) return DateTime.now();
		else return start;
	}

	@Override
	public List<GetCharactersCharacterIdPlanetsPlanetIdOkContents> getContents() {
		final List<GetCharactersCharacterIdPlanetsPlanetIdOkContents> cont = this.pinDelegate.getContents();
		if (null == cont) return new ArrayList<>();
		else return cont;
	}

	@Override
	public int getCpuUsage() {
		if (this.cpuUsage < 0) {
			final GetUniverseTypesTypeIdOkDogmaAttributes cpu = this.getDogmaAttributeById( 49 );
			if (null == cpu) return 0;
			else this.cpuUsage = cpu.getValue().intValue();
		}
		return this.cpuUsage;
	}

	@Override
	public int getPowerUsage() {
		if (this.powerUsage < 0) {
			final GetUniverseTypesTypeIdOkDogmaAttributes power = this.getDogmaAttributeById( 15 );
			if (null == power) return 0;
			else this.powerUsage = power.getValue().intValue();
		}
		return this.powerUsage;
	}

	@Override
	public FacilityGeoPosition getCommandCenterPosition() {
		return this.commandCenterPosition;
	}

	@Override
	public void setCommandCenterPosition( final FacilityGeoPosition commandCenterPosition ) {
		this.commandCenterPosition = commandCenterPosition;
	}

	@Override
	public GetUniverseTypesTypeIdOkDogmaAttributes getDogmaAttributeById( final int attributeId ) {
		final List<GetUniverseTypesTypeIdOkDogmaAttributes> attributes = this.planetItemDelegate.getType().getDogmaAttributes();
		for (final GetUniverseTypesTypeIdOkDogmaAttributes attribute : attributes) {
			if (attributeId == attribute.getAttributeId()) return attribute;
		}
		return null;
	}

	public Float getStorageCapacity() {
		final GetUniverseTypesTypeIdOkDogmaAttributes storage = this.getDogmaAttributeById( 38 );
		if (null == storage) return 0.0F;
		else return storage.getValue();
	}

	// - D E L E G A T I O N
	@Override
	public String getTypeIconURL() {
		return this.planetItemDelegate.getTypeIconURL();
	}

	// - I U N I Q U E M O D E L
	public long getUniqueModelIdentifier() {
		return this.pinDelegate.getPinId();
	}

	/**
	 * IPlanetaryFacility comparisons for ordering are related to the facility name
	 */
	@Override
	public int compareTo( final Object o ) {
		if (o instanceof IPlanetaryFacility) {
			return this.getFacilityType().getFacilityOrderIndex() - ((IPlanetaryFacility) o).getFacilityType().getFacilityOrderIndex();
		}
		return 0;
	}

	@Override
	public int hashCode() {
		return new HashCodeBuilder( 17, 37 ).appendSuper( super.hashCode() ).append( this.pinDelegate ).append( this.planetItemDelegate )
				.append( this.commandCenterPosition ).append( this.planetType ).append( this.cpuUsage ).append( this.powerUsage ).toHashCode();
	}

	// - C O R E
	@Override
	public boolean equals( final Object o ) {
		if (this == o) return true;
		if (!(o instanceof PlanetaryFacility)) return false;
		final PlanetaryFacility that = (PlanetaryFacility) o;
		return new EqualsBuilder().appendSuper( super.equals( o ) ).append( this.cpuUsage, that.cpuUsage )
				.append( this.powerUsage, that.powerUsage ).append( this.pinDelegate, that.pinDelegate ).append( this.planetItemDelegate, that.planetItemDelegate )
				.append( this.commandCenterPosition, that.commandCenterPosition ).append( this.planetType, that.planetType ).isEquals();
	}

	public IPlanetaryFacility setLastCycleStart( final DateTime lastCycleStart ) {
		this.pinDelegate.setLastCycleStart( lastCycleStart );
		return this;
	}

	// - B U I L D E R
	public static class Builder {
		private final PlanetaryFacility onConstruction;

		// - C O N S T R U C T O R S
		public Builder() {
			this.onConstruction = new PlanetaryFacility();
		}

		/**
		 * This builder method sets the schematic identifier that is the schematic to be used on the production plan for this facility.
		 * Not all structures have the ability to handle schematics to this is an optional method that should code gracefully with the
		 * case the data origin does not define one schematic.
		 */
		public PlanetaryFacility build() {
			Objects.requireNonNull( this.onConstruction.pinDelegate );
			Objects.requireNonNull( this.onConstruction.planetItemDelegate );
			Objects.requireNonNull( this.onConstruction.planetType );
			return this.onConstruction;
		}

		public Builder withFacilityItem( final EsiType planetItem ) {
			this.onConstruction.planetItemDelegate = planetItem;
			return this;
		}

		public Builder withPin( final GetCharactersCharacterIdPlanetsPlanetIdOkPins pin ) {
			this.onConstruction.pinDelegate = pin;
			return this;
		}

		public Builder withPlanetType( final PlanetType planetType ) {
			this.onConstruction.planetType = planetType;
			return this;
		}
	}
}
