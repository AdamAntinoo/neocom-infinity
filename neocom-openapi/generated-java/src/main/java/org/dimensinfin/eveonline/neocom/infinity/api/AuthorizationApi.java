/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (6.6.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.dimensinfin.eveonline.neocom.infinity.api;

import org.dimensinfin.eveonline.neocom.infinity.domain.BackendErrorDto;
import org.dimensinfin.eveonline.neocom.infinity.domain.RefreshTokenResponseDto;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
@Validated
@Tag(name = "Authorization", description = "NeoCom Authorization Endpoint set")
public interface AuthorizationApi {

    /**
     * GET /api/v1/neocom/refreshAuthorization : Get a new updated authorization token from Esi.
     * Get a new updated authorization token from Esi. Use the current Credential refresh token to access ESI and get a new valid and not expired authorization token.  Update the new token on the corresponding Credential and also update the NeoCom cookie on server response.  New token will last for another 15 minutes. 
     *
     * @param NEOCOM_TOKEN The access token to be used for authorization. This token will contain information to locate the credential to be used for data location. (required)
     * @return Token refresh completed successfully. A new authorization token is available. (status code 200)
     *         or Unauthorized. The current active access token is not present. The character identified thus cannot be accessed and the credential cannot be found. (status code 401)
     *         or Forbidden. The credential information is not valid to create a new access token and the authorization request is forbidden. (status code 403)
     *         or Not found. There is an access token and a credential identifier but that credential is no longer available at the repository. (status code 404)
     */
    @Operation(
        operationId = "refreshAuthorizationToken",
        summary = "Get a new updated authorization token from Esi.",
        description = "Get a new updated authorization token from Esi. Use the current Credential refresh token to access ESI and get a new valid and not expired authorization token.  Update the new token on the corresponding Credential and also update the NeoCom cookie on server response.  New token will last for another 15 minutes. ",
        tags = { "Authorization" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Token refresh completed successfully. A new authorization token is available.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = RefreshTokenResponseDto.class))
            }),
            @ApiResponse(responseCode = "401", description = "Unauthorized. The current active access token is not present. The character identified thus cannot be accessed and the credential cannot be found.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = BackendErrorDto.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden. The credential information is not valid to create a new access token and the authorization request is forbidden.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = BackendErrorDto.class))
            }),
            @ApiResponse(responseCode = "404", description = "Not found. There is an access token and a credential identifier but that credential is no longer available at the repository.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = BackendErrorDto.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/neocom/refreshAuthorization",
        produces = "application/json"
    )
    ResponseEntity<RefreshTokenResponseDto> refreshAuthorizationToken(
        @NotNull @Parameter(name = "NEOCOM-TOKEN", description = "The access token to be used for authorization. This token will contain information to locate the credential to be used for data location.", required = true, in = ParameterIn.COOKIE) @CookieValue(name = "NEOCOM-TOKEN") String NEOCOM_TOKEN
    );

}
